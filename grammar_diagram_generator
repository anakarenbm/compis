program ::= 'PROGRAM' 'ID' program1
program1 ::= script program2 | program2
program2 ::= htmltag program2 | empty

script ::= 'SCRIPT' block

block ::= 'OBRACE' declareBlock block1 'CBRACE'
block1 ::= statement block1 | module block1 | empty

/*
  Variable declaration/initialization not supported here
  Used in cycles and conditions.
*/
simpleBlock ::= 'OBRACE' simpleBlock1 'CBRACE'
simpleBlock1 ::= statement simpleBlock1 | empty

/*
  Defining new modules not supported here
  Used in void modules.
*/
voidModuleBlock ::= 'OBRACE' declareBlock voidModuleBlock1 'CBRACE'
voidModuleBlock1 ::= statement voidModuleBlock1 | empty

/*
  Defining new modules not supported here
  Used in modules that return something.
*/
returnModuleBlock ::= 'COLON' type 'OBRACE' declareBlock returnModuleBlock1 'CBRACE'
returnModuleBlock1 ::= statement returnModuleBlock1 | 'SPIT' expression

declareBlock ::= declare declareBlock | empty
declare ::= type 'ID' | type 'ID' initializeSlices | initialize

initialize ::= type initialize1 initialize2
initialize1 ::= 'ID' 'EQ' value | 'ID' initializeSlices 'EQ' constSlices
initialize2 ::= 'COMMA' initialize1 initialize2 | empty

initializeSlices ::= initializeSlices1D | initializeSlices2D
initializeSlices1D ::= 'OBRACK' 'CTEI' 'CBRACK'
initializeSlices2D ::= 'OBRACK' 'CTEI' 'CBRACK' 'OBRACK' 'CTEI' 'CBRACK'

constSlices ::= constSlice1D | constSlice2D
constSlice1D ::= 'OBRACK' value constSlice1D1 'CBRACK'
constSlice1D1 ::= 'COMMA' value constSlice1D1 | empty
/*TODO: FIX 2D SLICE*/
constSlice2D ::=  'OBRACK' constSlice1D 'COMMA' 'CBRACK' | 'OBRACK' constSlice1D 'CBRACK'

type ::= 'STR' | 'INT' | 'DOUBLE' | 'BOOL'

statement ::= assignment | condition | cycle | doCycle |call | writing

/*
assignment:
prev_var = "hi"
prev_slice[1] = 1+1
prev_mat[1][2] = 2
*/
assignment ::= 'ID'assignmentSlice 'EQ' expression
assignmentSlice ::= assignmentSlice1D | assignmentSlice2D | empty
assignmentSlice1D ::= 'OBRACK' expression 'CBRACK'
assignmentSlice2D ::= 'OBRACK' expression 'CBRACK' 'OBRACK' expression 'CBRACK'

expression ::= exp expression1
expression1 ::= 'REL' exp | 'ASSOCIATIVE' exp | empty

exp ::= term exp1
exp1 ::= 'SIGN' exp exp1 | empty

term ::= factor term1
term1 ::= 'OP' term term1 | empty

factor ::= 'OPAREN' expression 'CPAREN' | factor1
factor1 ::= value | 'SIGN' value

value ::= 'ID' | valueSlice | call | 'CTEI' | 'CTED' | 'CTESTR' | 'FALSE' | 'TRUE'
valueSlice ::= valueSlice1D | valueSlice2D
valueSlice1D ::= 'ID' 'OBRACK' expression 'CBRACK'
valueSlice2D ::= 'ID' 'OBRACK' expression 'CBRACK' 'OBRACK' expression 'CBRACK'

condition ::= 'IF' 'OPAREN' expression 'CPAREN' simpleBlock condition1
condition1 ::= 'ELSE' simpleBlock | empty

cycle ::= 'LOOP' 'OPAREN' expression 'CPAREN' simpleBlock

doCycle ::= 'DO' simpleBlock 'LOOP' 'OPAREN' expression 'CPAREN'


module ::= 'DEF' 'ID' 'OPAREN' arguments 'CPAREN' module1
module1 ::= voidModuleBlock | returnModuleBlock

call ::= 'ID' call1 | predef
call1 ::= 'OPAREN' params 'CPAREN'

params ::= expression params1
params1 ::= 'COMMA' params | empty

predef ::= predef_avg | predef_find_max | predef_find_min | predef_median | predef_mode | predef_find_mult_slice | predef_pow | predef_randoms | predef_sort_slice | predef_suck_csv | predef_zeros_args

predef_avg ::= 'AVG' 'OPAREN' 'ID' 'CPAREN'

predef_find_max ::= 'FIND_MAX' 'OPAREN' 'ID' 'COMMA' predef_find_max_args 'CPAREN'
predef_find_max_args ::= 'ID' | 'CTEI'

predef_find_min ::= 'FIND_MIN' 'OPAREN' 'ID' 'COMMA' predef_find_min_args 'CPAREN'
predef_find_min_args ::= 'ID' | 'CTEI'

predef_find_mult_slice ::= 'MULTIPLY_1DSLICE' 'OPAREN' 'ID' 'COMMA' predef_find_mult_slice_args 'CPAREN'
predef_find_mult_slice_args ::= 'ID' | 'CTEI'

predef_median ::= 'MEDIAN' 'OPAREN' 'ID' 'CPAREN'
predef_mode ::= 'MODE' 'OPAREN' 'ID' 'CPAREN'

predef_pow::= 'POW' 'OPAREN' predef_pow_args 'COMMA' predef_pow_args 'CPAREN'
predef_pow_args ::= 'ID' | 'CTEI'

predef_randoms ::= 'RANDOMS' 'OPAREN' predef_randoms_args 'CPAREN'
predef_randoms_args ::= 'ID' | 'CTEI'

predef_zeros ::= 'ZEROS' 'OPAREN' predef_zeros_args 'CPAREN'
predef_zeros_args ::= 'ID' | 'CTEI'

predef_sort_slice::= 'SORT_SLICE' 'OPAREN' 'ID' 'COMMA' predef_sort_slice_option 'CPAREN'
predef_sort_slice_option::= 'MAX' | 'MIN'

predef_suck_csv ::= 'SUCK_CSV' 'OPAREN' predef_suck_csv_args 'CPAREN'
predef_suck_csv_args ::= 'ID' | 'CTESTR'

writing ::= 'EVAL' 'OPAREN' expression 'CPAREN'

/* falta agregar slices */
arguments ::= type 'ID' arguments1 | empty
arguments1 ::= 'COMMA' type 'ID' arguments1 | empty

tag ::= 'H1' | 'H2' | 'DIV' | 'P' | 'TABLE' | 'TR' | 'TH'

html_class ::= 'CLASS' 'COLON' 'CTESTR' | empty

htmlscript ::= 'OEVALSCRIPT' expression 'CEVALSCRIPT'

/* -------- NEW HTML GAMMAR -------- */

htmltag ::= tag 'OBRACE' html_block 'CBRACE' | 'BR' 'OBRACE' 'CBRACE'

tag ::= 'H1' | 'H2' | 'DIV' | 'P' | 'TABLE' | 'TR' | 'TH'

html_block ::= html_statement html_block | htmltag html_block | empty

html_statement ::= html_assignment | html_condition | htmlscript | html_cycle | html_do_cycle| html_call | writing

html_assignment ::= 'INITCODEHTML' 'ID' 'EQ' expression 'CCODEHTML'

html_condition ::= 'INITCODEHTML' 'IF' 'OPAREN' expression 'CPAREN' 'CCODEHTML' html_block html_condition1_else html_end_condition
html_condition1_else ::= 'HTMLELSE' html_block | empty
html_end_condition ::= 'HTMLEND'


html_cycle ::= 'INITCODEHTML' 'LOOP' 'OPAREN' expression 'CPAREN' 'CCODEHTML' html_block html_end_cycle
html_end_cycle ::= 'HTMLEND'

html_do_cycle ::= 'INITCODEHTML' 'DO' 'CCODEHTML' html_block html_end_do_cycle
html_end_do_cycle ::= 'HTMLENDDO' 'OPAREN' expression 'CPAREN' 'CCODEHTML'

/* falta agregar predef a html calls (nuestras funciones propias)*/
html_call ::= 'INITCODEHTML' 'ID' 'OPAREN' params 'CPAREN' 'CCODEHTML'
